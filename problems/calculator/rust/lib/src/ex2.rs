///////////////////////////////////////////////////////////////////////////////
//! === Take 5 ================================================================
//!
//!
//!
///////////////////////////////////////////////////////////////////////////////

/// Abstract Symbol/ID
#[derive(PartialEq, Eq, Debug, Clone, Copy)]
struct ID;

///////////////////////////////////////////////////////////////////////////////

/// Abstract Value
#[derive(PartialEq, Eq, Debug, Clone)]
enum V {
    F(ID, Vec<V>),
    Leaf(ID),
}

///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////

/// Internal error ID
const ERR: ID = ID;

/// The identity function
const F_ID: ID = ID;

/// The addition function
const F_ADD: ID = ID;

/// The inverse function
const F_INV: ID = ID;

///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////

fn reduce(v: V) -> V {
    match v {
        V::F(id, args) if id == F_ID && args.len() == 1 => args[0].to_owned(),
        V::F(id, args) if id == F_ID => V::Leaf(ERR),

        V::F(id, args) if id == F_ADD && args.len() == 2 => todo!(),
        V::F(id, args) if id == F_ADD => V::Leaf(ERR),

        V::F(id, args) if id == F_INV && args.len() == 1 => todo!(),
        V::F(id, args) if id == F_INV => V::Leaf(ERR),

        // Cannot reduce further
        V::F(_, _) => v,
        V::Leaf(_) => v,
    }
}

///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use crate::ex2::{F_ADD, F_ID, F_INV};

    fn meta() {
        assert_ne!(F_ID, F_ADD);
        assert_ne!(F_ID, F_INV);
    }
}

///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------------//
///////////////////////////////////////////////////////////////////////////////
